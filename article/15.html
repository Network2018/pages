<!-- build time:Sat May 05 2018 01:46:54 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><link href="https://static.sometimesnaive.org:9004/deps/imgs/favicon.ico" type="image/x-icon" rel="icon"><title>Certificate Transparency 概述 | 南琴浪博客</title><link href="https://static.sometimesnaive.org:9004/deps/css/style.min.css" type="text/css" rel="stylesheet"><script src="https://static.sometimesnaive.org:9004/deps/js/jquery.min.js" type="application/javascript"></script><link href="https://static.sometimesnaive.org:9004/deps/css/nprogress.min.css" type="text/css" rel="stylesheet"><script src="https://static.sometimesnaive.org:9004/deps/js/nprogress.min.js" type="application/javascript"></script><link href="https://static.sometimesnaive.org:9004/deps/css/prism.min.css" type="text/css" rel="stylesheet"><script src="https://static.sometimesnaive.org:9004/deps/js/prism.min.js" type="application/javascript"></script><link href="https://static.sometimesnaive.org:9004/deps/css/gitment.min.css" type="text/css" rel="stylesheet"><script src="https://static.sometimesnaive.org:9004/deps/js/gitment.min.js" type="application/javascript"></script></head><body><header class="header fixed-header"><div class="header-container"><a class="home-link" href="/">南琴浪博客</a><ul class="right-list"><li class="list-item"><a href="/" class="item-link">Home</a></li><li class="list-item"><a href="/archive/" class="item-link">Archive</a></li><li class="list-item"><a href="/portal/atom.xml" class="item-link">RSS</a></li><li class="list-item"><a href="/portal/friendly-links" class="item-link">Links</a></li></ul><div class="menu-mask"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">Home</a></li><li class="menu-item"><a href="/archive/" class="menu-link">Archive</a></li><li class="menu-item"><a href="/portal/atom.xml" class="menu-link">RSS</a></li><li class="menu-item"><a href="/portal/friendly-links" class="menu-link">Links</a></li></ul></div></div></header><div id="article-banner"><h2>Certificate Transparency 概述</h2><p class="post-date">10/28/2017</p></div><main class="app-body flex-box"><article class="post-article"><section class="markdown-content"><p>在 <a href="https://sometimesnaive.org/article/12" rel="external nofollow noopener noreferrer" target="_blank">本博客 Nginx 配置（系列一） 安全篇</a> 中，我提到了 一种名为 Certificate Transparency 的用于 HTTPS 安全的方案，本文会介绍 Certificate Transparency 相关。<br><a id="more"></a></p><h2 id="什么是-Certificate-Transparency"><a href="#什么是-Certificate-Transparency" class="headerlink" title="什么是 Certificate Transparency"></a>什么是 Certificate Transparency</h2><p>HTTPS 站点的身份认证通过<code>证书信任链</code>完成：浏览器从站点证书开始，递归校验父证书，直至出现信任的根证书（这个根证书列表一般内置于操作系统，Firefox 则自己维护）。然而，世界上受信任的 CA 机构数量较大（几百个），它们组成了整个站点身份认证过程中一个较大的有机可乘的攻击面。此外，由于 CA 的失误签发了非法证书，或者甚至是个别 CA 出于某种目的故意签发非法证书（我可没说是沃通 Wosign 啊，我不是我没有你别瞎说啊），都能利用自己的受信任 CA 的身份，让这种非法证书成功通过现有的证书信任链校验机制。比起纯粹的自签名证书，这种非法证书更容易获得信任且更难被发现它的非法，即便被发现了，由于现有证书链信任机制的缺陷，也较难应对和更正。</p><p>为了解决这些瓶颈，Certificate Transparency 诞生了。</p><p>Certificate Transparency（中文直译：证书透明度，<a href="https://www.certificate-transparency.org" rel="external nofollow noopener noreferrer" target="_blank">官方主页</a>，<a href="https://tools.ietf.org/html/rfc6962" rel="external nofollow noopener noreferrer" target="_blank">RFC 6962</a>），有时简称 CT，它是一个实验性的 IETF 开源标准和开源框架，目的是<code>监测和审计数字证书</code>。通过证书日志、监控和审计系统，证书透明度使网站用户和域名持有者可以识别不当或恶意签发的证书，以及识别数字证书认证机构（CA）的作为，从而完善了证书信任链机制，能够进行更严密的证书合法性验证。</p><p>Certificate Transparency 机制由三部分组成：</p><ul><li>Certificate Logs</li><li>Certificate Monitors</li><li>Certificate Auditors</li></ul><p>完整的工作机制说明，请看 <a href="https://www.certificate-transparency.org/how-ct-works" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a></p><p>一般来说，证书所有者（或者是 CA）都可以主动向 Certificate Logs 服务器提交你的证书，所有证书记录都会接受监测和审计。Certificate Logs 服务器一般由 CA 部署（Google 也有部署，更多服务器列表请看 <a href="https://www.certificate-transparency.org/known-logs" rel="external nofollow noopener noreferrer" target="_blank">Known Logs</a>）。合法证书向 CT Logs 服务器的合法提交完成后，服务器会返回 SCT（Signed Certificate Timestamp）信息。这个 SCT 信息是 CT 机制所必须的。</p><p>然而，Certificate Transparency 现在有个很大的问题是，目前浏览器对它的兼容比较少。目前 Chrome 已默认对它提供支持，Firefox 则需要修改 security.pki.certificate_transparency.mode 为 true。</p><p>CT 和 HPKP 实现的目的类似，由于 CT 的浏览器兼容性不佳，所以一般只启用 HPKP 而不启用 CT 也无大碍。关于 HPKP，可以参看 <a href="https://sometimesnaive.org/article/9#HTTP Public Key Pinning" rel="external nofollow noopener noreferrer" target="_blank">我的另一篇文章</a>。当然，因为鄙人的强迫症，本站已启用这两样特性。</p><h2 id="启用-CT-的三种方式"><a href="#启用-CT-的三种方式" class="headerlink" title="启用 CT 的三种方式"></a>启用 CT 的三种方式</h2><p>有以下三种方式启用 CT ：</p><h3 id="X-509v3-扩展"><a href="#X-509v3-扩展" class="headerlink" title="X.509v3 扩展"></a>X.509v3 扩展</h3><p>CA 先预签证书，并将预签证书提交给 CT Logs 服务器，得到 SCT 信息，然后 CA 将 SCT 信息作为预签证书的扩展再次签名，得到一个含有 SCT 扩展的证书。<br>这种方式的好处在于，<code>站点证书的使用者不需要任何操作</code>就能直接拿到带有 SCT 拓展的证书。但对于 CA 来说，需要实时提交证书拿到 SCT、先后签署两次证书，对于 CA 来说成本较高，但这个方案是以后的趋势。Digicert、Trustasia、Let’s Encrypt 已支持这种方案</p><blockquote><p>Let’s Encrypt 已支持这种方案 <a href="https://letsencrypt.org/certificates" rel="external nofollow noopener noreferrer" target="_blank">via</a></p><blockquote><p>We are dedicated to transparency in our operations and in the certificates we issue. We submit all certificates to Certificate Transparency logs as we issue them.</p></blockquote></blockquote><h3 id="TLS-扩展"><a href="#TLS-扩展" class="headerlink" title="TLS 扩展"></a>TLS 扩展</h3><p>当然了，除了 CA 预提交这种情况，我们也可以自己提交证书给 CT Logs 服务器，记录 SCT 信息（如何提交证书和获取 SCT，我会在下面讲到）。然后配置 Web Server，使其能在 TLS 握手阶段的 Server Hello 响应中启用 Signed_Certificate_Timestamp 扩展，传递 SCT 信息。<br>这种方式对于 CA 来说是 0 成本。而对于用户，<code>需要自己提交证书、配置 Signed_Certificate_Timestamp 扩展</code>，成本较高。</p><h3 id="通过-OCSP-Stapling"><a href="#通过-OCSP-Stapling" class="headerlink" title="通过 OCSP Stapling"></a>通过 OCSP Stapling</h3><p>提交证书，获取到 SCT 后，和“上面 TLS 扩展 中所讲的 Signed_Certificate_Timestamp 拓展”的传递 SCT 的方式不同，还有一种传递 SCT 的方式是，通过改造 OCSP 文件，<code>将 SCT 信息写入到 OCSP 文件中</code>，服务端启用 OCSP Stapling 后，就可以将 SCT 信息放入证书的 OCSP 查询结果中。关于 OCSP Stapling，可以参看 <a href="https://sometimesnaive.org/article/13" rel="external nofollow noopener noreferrer" target="_blank">我的这篇文章</a></p><h2 id="Nginx-启用-CT"><a href="#Nginx-启用-CT" class="headerlink" title="Nginx 启用 CT"></a>Nginx 启用 CT</h2><p>TLS 扩展是适应最广泛的方案：</p><p>准备好你的中间证书和站点证书，按照<code>站点证书在上、中间证书在下</code>的顺序，将两个证书的内容复制粘贴到一个文件 <code>ct.cer</code> 中</p><h3 id="获取-SCT-文件"><a href="#获取-SCT-文件" class="headerlink" title="获取 SCT 文件"></a>获取 SCT 文件</h3><p>通过 <code>ct-submit</code> 这个工具 ，可以很方便地将证书提交给 CT Logs 服务器，并得到 SCT 回应</p><pre><code class="language-bash"># 编译这个工具，需要 go 语言支持
apt-get install -y golang
wget -O ct-submit-1.1.2.zip https://github.com/grahamedgecombe/ct-submit/archive/v1.1.2.zip
unzip ct-submit-1.1.2.zip
cd ct-submit-1.1.2
go build

# 备用下载，这是我已经编译好的
wget https://raw.githubusercontent.com/nanqinlang/nginx/master/ct-submit-1.1.2.zip &amp;&amp; unzip ct-submit-1.1.2.zip
</code></pre><p>编译完成后，当前目录会出现 <code>ct-submit-1.1.2</code> 这个文件，赋予执行权限后运行它</p><pre><code class="language-bash">chmod 7777 ct-submit-1.1.2
./ct-submit-1.1.2 ct.googleapis.com/icarus &lt;ct.cer &gt;ct.sct
</code></pre><p>以上，把证书文件 <code>ct.cer</code> 提交给 Google 的 CT Logs 服务器，并在当前目录生成 SCT 文件 <code>ct.sct</code>。更多可用的 CT Logs 服务器，我在上面已提到过，建议选择 Google 的服务器的其中一个即可。</p><h3 id="Nginx-编译-CT-模块"><a href="#Nginx-编译-CT-模块" class="headerlink" title="Nginx 编译 CT 模块"></a>Nginx 编译 CT 模块</h3><p>要令 Nginx 支持 TLS 扩展，需要加入 <a href="https://github.com/grahamedgecombe/nginx-ct" rel="external nofollow noopener noreferrer" target="_blank"><code>nginx-ct</code></a> 这个模块</p><pre><code class="language-bash">wget -O nginx-ct-1.3.2.zip https://github.com/grahamedgecombe/nginx-ct/archive/v1.3.2.zip
unzip nginx-ct-1.3.2.zip
./configure --... --add-module=.../nginx-ct-1.3.2
make &amp;&amp; make install

# 备用下载
wget https://raw.githubusercontent.com/nanqinlang/nginx/master/nginx-ct-1.3.2.zip &amp;&amp; unzip nginx-ct-1.3.2.zip
</code></pre><h3 id="Nginx-站点配置"><a href="#Nginx-站点配置" class="headerlink" title="Nginx 站点配置"></a>Nginx 站点配置</h3><p>接下来，要在你的 Nginx 配置文件中加入如下：</p><pre><code class="language-nginx">server {
# 开启 CT
ssl_ct on;
# 和 Nginx 的一般规则不同，这里不是指定文件，而是写入你的 ct.sct 所在的路径
ssl_ct_static_scts    /home/sometimesnaive.org/crt;
</code></pre><p>之后启动 Nginx。至此，Nginx 对 CT 的启用就完成了。</p><p>可以访问 <a href="https://www.ssllabs.com/ssltest/index" rel="external nofollow noopener noreferrer" target="_blank">ssllabs</a> 进行 SSL 测试，其中能看到 Certificate Transparency 开启与否的报告。</p></section><br><div class="article-footer"><br><p>本文可能过时失效，若需更新，请留言</p><p>本博客文章均为原创，转载请注明来源</p></div><div class="nav-container"><a class="nav-right" href="/article/14.html">Hexo 搬迁记（一） 安装篇 <span class="nav-arrow">→</span> </a><a class="nav-left" href="/article/16.html"><span class="nav-arrow">← </span>本博客 Nginx 配置（系列二） 性能篇</a></div><div id="comments"></div></article><aside class="catalog-container"><div class="toc-main"><strong class="toc-title">Catalog</strong><ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#什么是-Certificate-Transparency"><span class="toc-nav-text">什么是 Certificate Transparency</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#启用-CT-的三种方式"><span class="toc-nav-text">启用 CT 的三种方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#X-509v3-扩展"><span class="toc-nav-text">X.509v3 扩展</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#TLS-扩展"><span class="toc-nav-text">TLS 扩展</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#通过-OCSP-Stapling"><span class="toc-nav-text">通过 OCSP Stapling</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Nginx-启用-CT"><span class="toc-nav-text">Nginx 启用 CT</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#获取-SCT-文件"><span class="toc-nav-text">获取 SCT 文件</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Nginx-编译-CT-模块"><span class="toc-nav-text">Nginx 编译 CT 模块</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Nginx-站点配置"><span class="toc-nav-text">Nginx 站点配置</span></a></li></ol></li></ol></div></aside></main><script>!function(){var e="https://static.sometimesnaive.org:9004/deps/imgs/banner.jpg";$("#article-banner").css({"background-image":"url("+e+")"}),$(".header").removeClass("fixed-header")}()</script><script>(function(){
    var gitmentConfig = "nanqinlang"
    if (gitmentConfig !== 'undefined') {
        var gitment = new Gitment({
            id: "15",
            owner: "nanqinlang",
            repo: "sometimesnaive.org",
            oauth: {client_id: "b0612de512484ab34c7a", client_secret: "c2bc4cd3c947097d2ccc4c16f120d50458314dd0"},
            theme: {render(state, instance){const container = document.createElement('div');container.lang="en-US";container.className='gitment-container gitment-root-container';container.appendChild(instance.renderHeader(state, instance));container.appendChild(instance.renderEditor(state, instance));container.appendChild(instance.renderComments(state, instance));container.appendChild(instance.renderFooter(state, instance));return container;}}
        })
        gitment.render(document.getElementById('comments'))
    }
})();</script><div class="scroll-top"><span class="arrow-icon"></span></div><footer class="app-footer"><p class="copyright" align="center">&copy; 2017 - 2018 南琴浪博客 <a>(sometimesnaive.org)<a></a></a></p></footer><script src="https://static.sometimesnaive.org:9004/deps/js/function.min.js" type="application/javascript"></script><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-108266909-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js" type="application/javascript"></script></body></html><!-- rebuild by neat -->